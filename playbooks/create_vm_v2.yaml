- hosts: localhost
  vars:
    vm_name: "{{ vm_name }}"  # VM name
    vm_namespace: "aap-vm-auto-provision-test"  # Target namespace
    source_ref_name: "rhel9"  # Template or image source name
    source_ref_namespace: "openshift-virtualization-os-images"  # Namespace of the template
    instancetype_name: "u1.medium"  # Instance type
    preference_name: "rhel.9"  # Preference type
    bridge_network_name: "default/bridge-br1"  # Name of the bridge network attachment definition
    user_password: "{{ user_password }}"  # Cloud-init password
    user_name: "{{ user_name }}"  # Cloud-init user

  tasks:
    # Step 1: Validate the namespace
    - name: Check if the target namespace exists
      kubernetes.core.k8s_info:
        api_version: v1
        kind: Namespace
        name: "{{ vm_namespace }}"
      register: ns_info
      failed_when: ns_info.resources | length == 0
      ignore_errors: true

    - name: Create namespace if it does not exist
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: v1
          kind: Namespace
          metadata:
            name: "{{ vm_namespace }}"
      when: ns_info.resources | length == 0

    - name: Validate namespace creation
      fail:
        msg: "Namespace {{ vm_namespace }} could not be created and does not exist."
      when: ns_info.resources | length == 0

    # Step 2: Create the Virtual Machine
    - name: Create VM using the provided template
      kubernetes.core.k8s:
        state: present
        definition:
          apiVersion: kubevirt.io/v1
          kind: VirtualMachine
          metadata:
            name: "{{ vm_name }}"
            namespace: "{{ vm_namespace }}"
          spec:
            dataVolumeTemplates:
              - metadata:
                  name: "{{ vm_name }}-volume"
                spec:
                  sourceRef:
                    kind: DataSource
                    name: "{{ source_ref_name }}"
                    namespace: "{{ source_ref_namespace }}"
                  storage:
                    resources: {}
            instancetype:
              name: "{{ instancetype_name }}"
            preference:
              name: "{{ preference_name }}"
            running: true
            template:
              metadata:
                labels:
                  network.kubevirt.io/headlessService: headless
              spec:
                domain:
                  devices:
                    interfaces:
                      - name: default
                        masquerade: {}
                      - name: bridge-br1
                        bridge: {}
                networks:
                  - name: default
                    pod: {}
                  - name: bridge-br1
                    multus:
                      networkName: "{{ bridge_network_name }}"
                subdomain: headless
                volumes:
                  - dataVolume:
                      name: "{{ vm_name }}-volume"
                    name: rootdisk
                  - cloudInitNoCloud:
                      userData: |
                        #cloud-config
                        chpasswd:
                          expire: false
                        password: {{ user_password }}
                        user: {{ user_name }}
                    name: cloudinitdisk

    # Step 3: Wait for the VM to be ready
    - name: Wait for the VM to be ready
      kubernetes.core.k8s_info:
        api_version: kubevirt.io/v1
        kind: VirtualMachineInstance
        name: "{{ vm_name }}"
        namespace: "{{ vm_namespace }}"
      register: vmi
      retries: 60
      delay: 10
      until: >
        (vmi.resources | length > 0) and
        (vmi.resources[0].status.phase == "Running") and
        (vmi.resources[0].status.interfaces | default([]) | length > 0) and
        (
          vmi.resources[0].status.interfaces | map(attribute='ipAddress') | select('defined') | list | length ==
          (vmi.resources[0].status.interfaces | length)
        )

    # Step 4: Gather the IP addresses of all VM interfaces
    - name: Gather IP addresses of all VM interfaces as a structured list
      set_fact:
        vm_interfaces: >
          [{% for interface in vmi.resources[0].status.interfaces %}
            {"name": "{{ interface.name }}", "ip": "{{ interface.ipAddress | default('No IP assigned') }}"}
          {% endfor %}]

    # Step 5: Use the gathered IPs (Example usage)
    - name: Use the gathered IPs (Example: Print only specific IPs or process further)
      debug:
        msg: >
          The IP of the default interface is: {{
            (vm_interfaces | selectattr('name', 'equalto', 'default') | map(attribute='ip') | list | first | default('No IP assigned'))
          }}
          The IP of the bridge-br1 interface is: {{
            (vm_interfaces | selectattr('name', 'equalto', 'bridge-br1') | map(attribute='ip') | list | first | default('No IP assigned'))
          }}
